usethis::use_version()
devtools::load_all(".")
devtools::check(args = "--as-cran")
devtools::load_all(".")
devtools::check(args = "--as-cran")
source("~/Library/CloudStorage/GoogleDrive-l.danese1@campus.unimib.it/My Drive/Dottorato/Progetti/BayesChange/R/ClustCpObj.R")
devtools::load_all(".")
devtools::load_all(".")
rm(list = c("ClustCpObj", "plot_psm"))
devtools::load_all(".")
devtools::check(args = "--as-cran")
devtools::load_all(".")
devtools::check(args = "--as-cran")
devtools::load_all(".")
devtools::load_all(".")
devtools::check(args = "--as-cran")
devtools::load_all(".")
devtools::check(args = "--as-cran")
devtools::load_all(".")
devtools::check(args = "--as-cran")
devtools::load_all(".")
devtools::check(args = "--as-cran")
devtools::load_all(".")
devtools::check(args = "--as-cran")
devtools::load_all(".")
devtools::check(args = "--as-cran")
devtools::load_all(".")
devtools::check(args = "--as-cran")
devtools::load_all(".")
devtools::check(args = "--as-cran")
devtools::load_all(".")
devtools::load_all(".")
devtools::check(args = "--as-cran")
devtools::load_all(".")
devtools::check(args = "--as-cran")
devtools::load_all(".")
devtools::check(args = "--as-cran")
rhub::check_for_cran()
install.packages("rhub")
rhub::validate_email()
rhub::check_for_cran()
?rhubv2
rhub::rhub_setup()
rhub::rhub_check()
rhub::rhub_check()
1,2,3,4,5
c(1,2,3,4,5)
rhub::rhub_check()
devtools::load_all(".")
devtools::load_all(".")
devtools::check(args = "--as-cran")
rhub::rhub_check()
devtools::check(args = "--as-cran")
rhub::rhub_check()
rhub::rhub_check()
?clust_cp
data("stock_multi")
params_multi <- list(m_0 = rep(0,2),
k_0 = 1,
nu_0 = 10,
S_0 = diag(1,2,2),
phi = 0.1)
out_test <- clust_cp(data = stock_multi[,,1:5], n_iterations = 7500, n_burnin = 2500,
L = 1, B = 10000, params = params_multi, kernel = "ts")
est <- posterior_estimate(out_test, maxNClusters = 3)
if(length(table(est)) <= 5 & length(table(est)) >= 1){
check = TRUE
} else {
check = FALSE
}
check
devtools::load_all(".")
rhub::rhub_check()
devtools::check(args = "--as-cran")
# preliminaries
rm(list=ls())
set.seed(12345678)
#BiocManager::install("graph")
#BiocManager::install("RBGL")
#BiocManager::install("Rgraphviz")
#install.packages("https://www.bnlearn.com/releases/bnlearn_latest.tar.gz", repos = NULL, type = "source")
library(mvtnorm)
library(pcalg)
library(gRbase)
library(matrixNormal)
library(huge)
library(glmnet)
source("auxiliaries.R")
source("move_dag.R")
setwd("~/Library/CloudStorage/GoogleDrive-l.danese1@campus.unimib.it/My Drive/Progetti/DID/code")
source("auxiliaries.R")
source("move_dag.R")
source("move_dag.R")
# fix framework
M <- 5000  # num of MCMC iterations
burn <- M/2 # num of burned iterations
a_pi <- 1
# read min wage data
D <- read.table("public.dat")
# restrict to those who answered 2nd time
D <- D[D[,29]==1,]
dim(D)
# remove those with missings in Y
to.canc <- sort(unique(which(D[,c(12:17,21:27,32:37,40:46)]=='.',arr.ind=TRUE)[,1]))
D <- D[-to.canc,]
dim(D)
# separation in the four groups
X0.c <- as.matrix(D[D[,4]==0,c(2,3,5:10)])
#Y0.c <- as.matrix(D[D[,4]==0,c(12:17,22:27)])
Y0.c <- as.matrix(D[D[,4]==0,c(12:14,16:17,22:27)]) # wo wageST
X0.t <- as.matrix(D[D[,4]==1,c(2,3,5:10)])
#Y0.t <- as.matrix(D[D[,4]==1,c(12:17,22:27)])
Y0.t <- as.matrix(D[D[,4]==1,c(12:14,16:17,22:27)]) # wo wageST
X1.c <- as.matrix(D[D[,4]==0,c(2,3,5:10)])
#Y1.c <- as.matrix(D[D[,4]==0,c(32:37,41:46)])
Y1.c <- as.matrix(D[D[,4]==0,c(32:34,36:37,41:46)]) # wo wageST
X1.t <- as.matrix(D[D[,4]==1,c(2,3,5:10)])
#Y1.t <- as.matrix(D[D[,4]==1,c(32:37,41:46)])
Y1.t <- as.matrix(D[D[,4]==1,c(32:34,36:37,41:46)]) # wo wageST
# stack in X
n <- nrow(D)
X <- matrix(NA,2*n,ncol(X0.c))
X[seq(1,2*nrow(X0.c),by=2),] <- X0.c
X[seq(2,2*nrow(X0.c),by=2),] <- X1.c
X[seq(2*nrow(X0.c)+1,2*n,by=2),] <- X0.t
X[seq(2*nrow(X0.c)+2,2*n,by=2),] <- X1.t
Te <- rep(c(0,1),length=2*n)  # post-time vector
Z  <- rep(c(0,1),c(2*nrow(X0.c),2*nrow(X0.t)))  # subject treatment vector
X  <- cbind(1,X,Te,Z,Te*Z)
p  <- ncol(X)
# stack in Y
Y <- matrix(NA,2*n,ncol(Y0.c))
Y[seq(1,2*nrow(Y0.c),by=2),] <- Y0.c
Y[seq(2,2*nrow(Y0.c),by=2),] <- Y1.c
Y[seq(2*nrow(Y0.c)+1,2*n,by=2),] <- Y0.t
Y[seq(2*nrow(Y0.c)+2,2*n,by=2),] <- Y1.t
Y <- matrix(as.numeric(Y),nr=2*n)
#Y[,c(1:3,5,7,11:12)] <- log(Y[,c(1:3,5,7,11:12)]+10e-8)
Y[,c(1:4,6,10:11)] <- log(Y[,c(1:4,6,10:11)]+10e-8) # wo wageST
Y <- jitter(Y)
q <- ncol(Y)
b_pi <- q
# hyper prior values
C.prior <- diag(1/10000,p)
B.prior <- matrix(0,p,q)
# MCMC initialization
D0.chain <- Sigma0.chain <- array(NA,c(q,q,M))
B0.chain <- array(NA,c(p,q,M))
w1.chain  <- w2.chain <- rep(NA,M)
D0i   <- diag(0,q)
cardO <- q
prior0    <- lgamma(sum(D0i)+a_pi)+
lgamma(q*(q-1)/2-sum(D0i)+b_pi-1)
#V <- kronecker(diag(1,n),W)
#m0 <- mW(Y,X,as(t(D0i),"graphNEL"),B.prior,C.prior,diag(q),V)
w1  <- w2 <- 0.5
W1 <- matrix(c(1,w1,w1,1),2)
W2 <- matrix(c(1,w2,w2,1),2)
#m0 <- mW2(Y,X,as(t(D0i),"graphNEL"),B.prior,C.prior,diag(q),W1,W2,Z)
m0 <- mW(Y,X,as(t(D0i),"graphNEL"),B.prior,C.prior,diag(q),W1)
accrate0 <- accrate0.w <- 0
Y
colMeans(Y)
apply(Y, 2, sd)
Y[,1]
D
# preliminaries
rm(list=ls())
set.seed(12345678)
#BiocManager::install("graph")
#BiocManager::install("RBGL")
#BiocManager::install("Rgraphviz")
#install.packages("https://www.bnlearn.com/releases/bnlearn_latest.tar.gz", repos = NULL, type = "source")
library(mvtnorm)
library(pcalg)
library(gRbase)
library(matrixNormal)
library(huge)
library(glmnet)
source("auxiliaries.R")
source("move_dag.R")
# fix framework
M <- 5000  # num of MCMC iterations
burn <- M/2 # num of burned iterations
a_pi <- 1
# read min wage data
D <- read.table("public.dat")
# restrict to those who answered 2nd time
D <- D[D[,29]==1,]
dim(D)
# remove those with missings in Y
to.canc <- sort(unique(which(D[,c(12:17,21:27,32:37,40:46)]=='.',arr.ind=TRUE)[,1]))
D <- D[-to.canc,]
dim(D)
# separation in the four groups
X0.c <- as.matrix(D[D[,4]==0,c(2,3,5:10)])
#Y0.c <- as.matrix(D[D[,4]==0,c(12:17,22:27)])
Y0.c <- as.matrix(D[D[,4]==0,c(12:14,16:17,22:27)]) # wo wageST
X0.t <- as.matrix(D[D[,4]==1,c(2,3,5:10)])
#Y0.t <- as.matrix(D[D[,4]==1,c(12:17,22:27)])
Y0.t <- as.matrix(D[D[,4]==1,c(12:14,16:17,22:27)]) # wo wageST
X1.c <- as.matrix(D[D[,4]==0,c(2,3,5:10)])
#Y1.c <- as.matrix(D[D[,4]==0,c(32:37,41:46)])
Y1.c <- as.matrix(D[D[,4]==0,c(32:34,36:37,41:46)]) # wo wageST
X1.t <- as.matrix(D[D[,4]==1,c(2,3,5:10)])
#Y1.t <- as.matrix(D[D[,4]==1,c(32:37,41:46)])
Y1.t <- as.matrix(D[D[,4]==1,c(32:34,36:37,41:46)]) # wo wageST
# stack in X
n <- nrow(D)
X <- matrix(NA,2*n,ncol(X0.c))
X[seq(1,2*nrow(X0.c),by=2),] <- X0.c
X[seq(2,2*nrow(X0.c),by=2),] <- X1.c
X[seq(2*nrow(X0.c)+1,2*n,by=2),] <- X0.t
X[seq(2*nrow(X0.c)+2,2*n,by=2),] <- X1.t
Te <- rep(c(0,1),length=2*n)  # post-time vector
Z  <- rep(c(0,1),c(2*nrow(X0.c),2*nrow(X0.t)))  # subject treatment vector
X  <- cbind(1,X,Te,Z,Te*Z)
p  <- ncol(X)
# stack in Y
Y <- matrix(NA,2*n,ncol(Y0.c))
Y[seq(1,2*nrow(Y0.c),by=2),] <- Y0.c
Y[seq(2,2*nrow(Y0.c),by=2),] <- Y1.c
Y[seq(2*nrow(Y0.c)+1,2*n,by=2),] <- Y0.t
Y[seq(2*nrow(Y0.c)+2,2*n,by=2),] <- Y1.t
Y <- matrix(as.numeric(Y),nr=2*n)
#Y[,c(1:3,5,7,11:12)] <- log(Y[,c(1:3,5,7,11:12)]+10e-8)
Y[,c(1:4,6,10:11)] <- log(Y[,c(1:4,6,10:11)]+10e-8) # wo wageST
Y[,1] <- Y[,1]/10
Y <- jitter(Y)
q <- ncol(Y)
b_pi <- q
# hyper prior values
C.prior <- diag(1/10000,p)
B.prior <- matrix(0,p,q)
# MCMC initialization
D0.chain <- Sigma0.chain <- array(NA,c(q,q,M))
B0.chain <- array(NA,c(p,q,M))
w1.chain  <- w2.chain <- rep(NA,M)
D0i   <- diag(0,q)
cardO <- q
prior0    <- lgamma(sum(D0i)+a_pi)+
lgamma(q*(q-1)/2-sum(D0i)+b_pi-1)
#V <- kronecker(diag(1,n),W)
#m0 <- mW(Y,X,as(t(D0i),"graphNEL"),B.prior,C.prior,diag(q),V)
w1  <- w2 <- 0.5
W1 <- matrix(c(1,w1,w1,1),2)
W2 <- matrix(c(1,w2,w2,1),2)
#m0 <- mW2(Y,X,as(t(D0i),"graphNEL"),B.prior,C.prior,diag(q),W1,W2,Z)
m0 <- mW(Y,X,as(t(D0i),"graphNEL"),B.prior,C.prior,diag(q),W1)
accrate0 <- accrate0.w <- 0
for(i.iter in 1:M){
if(i.iter%%100==0) cat(i.iter,"\ ")
## w from its uniform proposal
w1.prop <- runif(1,max(0,w1-0.01),min(1,w1+0.01))
W1.prop <- matrix(c(1,w1.prop,w1.prop,1),2)
# compute w acceptance prob (uniform prior)
m.new    <- mW(Y,X,as(t(D0i),"graphNEL"),B.prior,C.prior,diag(q),W1.prop)
marg.new <- m.new$marg
marg.old <- m0$marg
ratio_D  <- min(0,marg.new-marg.old-
n*q/2*(log(1-w1.prop^2)-log(1-w1^2)))
# accept / reject w move
if(log(runif(1)) < ratio_D){
m0     <- m.new
w1      <- w1.prop
W1      <- W1.prop
#w2      <- w2.prop
#W2      <- W2.prop
if(i.iter> burn) accrate0.w <- accrate0.w+1
}
w1.chain[i.iter] <- w1
#w2.chain[i.iter] <- w2
## propose dag ##
moveD      <- move(A = D0i)
DAG_prop   <- moveD$A_new
cardO_prop <- moveD$cardO
# compute DAG acceptance prob
prior.new <- lgamma(sum(DAG_prop) + a_pi) +
lgamma(q*(q-1)/2 - sum(DAG_prop) + b_pi - 1)
#m.new    <- mW2(Y,X,as(t(DAG_prop),"graphNEL"),
#               B.prior,C.prior,diag(q),W1,W2,Z)
m.new    <- mW(Y,X,as(t(DAG_prop),"graphNEL"),
B.prior,C.prior,diag(q),W1)
marg.new <- m.new$marg
marg.old <- m0$marg
ratio_D  <- min(0,marg.new-marg.old+prior.new-prior0+
log(cardO_prop)-log(cardO))
# accept / reject DAG move
if(log(runif(1)) < ratio_D){
D0i    <- DAG_prop
prior0 <- prior.new
m0     <- m.new
cardO  <- cardO_prop
if(i.iter> burn) accrate0 <- accrate0+1
}
D0.chain[,,i.iter] <- D0i
## sample Cholesky D ##
paj    <- lapply(1:q,pa,D0i)
faj    <- lapply(1:q,fa,D0i)
vj     <- sapply(paj,length)
cj     <- (2*vj+3) - vj
U.post <- m0$U.post
schurs <- sapply(1:q,function(j)schur(U.post,j,paj[[j]]))
D.sigma0i <- 1/rgamma(q,(cj+2*n)/2-1,schurs/2)
## sample Cholesky L ##
L0i       <- diag(q)
for(j in 1:q){
if(!is.null(paj[[j]])){
Uminus <- solve(U.post[paj[[j]],paj[[j]]])
L.mean <- -Uminus%*%U.post[paj[[j]],j]
L.var  <- D.sigma0i[j]*Uminus
L.var  <- as.matrix(L.var)
L.var[lower.tri(L.var)] <- t(L.var)[lower.tri(L.var)]
L0i[paj[[j]],j] <- rmvnorm(1,L.mean,L.var)
}}
L.inv <- solve(L0i)
# compute and store covariance mat
Sigma0i <- t(L.inv)%*%diag(D.sigma0i)%*%L.inv
Sigma0i[lower.tri(Sigma0i)] <- t(Sigma0i)[lower.tri(Sigma0i)]
Sigma0.chain[,,i.iter] <- Sigma0i
## sample B ##
C.update <- blockprod(t(X),solve(W1))%*%X
C.update[lower.tri(C.update)] <- t(C.update)[lower.tri(C.update)]
C.update <- solve(C.prior+C.update)
C.update[lower.tri(C.update)] <- t(C.update)[lower.tri(C.update)]
B0i <- matrixNormal::rmatnorm(M=m0$B.est,U=C.update,V=Sigma0i)
B0.chain[,,i.iter] <- B0i
}
