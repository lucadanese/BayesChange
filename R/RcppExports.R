# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

Likelihood_UniTS <- function(data, order, gamma_par, a, b, c) {
    .Call(`_BayesCPs_Likelihood_UniTS`, data, order, gamma_par, a, b, c)
}

Likelihood_MultiTS <- function(data, order, gamma, k_0, nu_0, phi_0, m_0) {
    .Call(`_BayesCPs_Likelihood_MultiTS`, data, order, gamma, k_0, nu_0, phi_0, m_0)
}

norm_constant_uni <- function(data, gamma_par, R, a, b, c, p, print_progress = TRUE) {
    .Call(`_BayesCPs_norm_constant_uni`, data, gamma_par, R, a, b, c, p, print_progress)
}

norm_constant_multi <- function(data, gamma_par, R, k_0, nu_0, phi_0, m_0, p, print_progress = TRUE) {
    .Call(`_BayesCPs_norm_constant_multi`, data, gamma_par, R, k_0, nu_0, phi_0, m_0, p, print_progress)
}

#' Simulate epidemiological data
#'
#' @param S0 First value
#' @param I0 Second value
#' @param MaxTime Prova
#' @param beta_vec Prova
#' @param gamma_0 Prova
#' @param user_seed Prova
#' @return TO DO
#'
sim_epi_data <- function(S0, I0, MaxTime, beta_vec, gamma_0, user_seed = 1234L) {
    .Call(`_BayesCPs_sim_epi_data`, S0, I0, MaxTime, beta_vec, gamma_0, user_seed)
}

#' Compute the posterior similarity matrix
#'
#' @param M A matrix where each row corresponds to the output cluster of the corresponding iteration.
#' @return Function \code{psm} returns an \eqn{n}\eqn{\times}\eqn{n} posterior similarity matrix.
#'
psm <- function(M) {
    .Call(`_BayesCPs_psm`, M)
}

#' Estimate order
#'
#' @param orders_mat A matrix where each row corresponds to the output cluster of the corresponding iteration.
#' @return Function \code{get_clust_VI} returns a point estimate for the clustering of the data.
#'
#' @export
get_clust_VI <- function(orders_mat) {
    .Call(`_BayesCPs_get_clust_VI`, orders_mat)
}

#' Detect Change Points on an univariate time series.
#'
#' @param data vector of observations.
#' @param n_iterations number of MCMC iteration.
#' @param q probability of performing a split at each iterations.
#' @param phi parameter \eqn{\phi} of the integrated likelihood function.
#' @param a,b,c parameters of the Normal-Gamma prior for \eqn{\mu} and \eqn{\lambda}.
#' @param par_theta_c,par_theta_d parameters of the shifted Gamma prior for \eqn{\theta}.
#' @param print_progress If TRUE (default) print the progress bar.
#' @param user_seed seed for random distribution generation.
#' @return Function \code{detect_cp_uni} returns a list containing the following components: \itemize{
#' \item{\code{$orders}} a matrix where each row corresponds to the output order of the corresponding iteration.
#' \item{\code{$sigma_MCMC}} traceplot for \eqn{\sigma}.
#' \item{\code{$sigma_MCMC_01}} a \eqn{0/1} vector, the \eqn{n}-th element is equal to \eqn{1} if the proposed \eqn{\sigma} was accepted, \eqn{0} otherwise.
#' \item{\code{$theta_MCMC}} traceplot for \eqn{\theta}.
#' }
#'
#' @examples
#'
#' data_vec <- as.numeric(c(rnorm(50,0,0.1), rnorm(50,1,0.25)))
#'
#' out <- detect_cp_uni(data = data_vec,
#'                             n_iterations = 2500,
#'                             q = 0.25,
#'                             phi = 0.1, a = 1, b = 1, c = 0.1)
#'
#' get_clust_VI(out$order)
#' @export
detect_cp_uni <- function(data, n_iterations, q, phi, a, b, c, par_theta_c = 1, par_theta_d = 1, print_progress = TRUE, user_seed = 1234L) {
    .Call(`_BayesCPs_detect_cp_uni`, data, n_iterations, q, phi, a, b, c, par_theta_c, par_theta_d, print_progress, user_seed)
}

#' Detect Change Points on multivariate time series
#'
#' @param data a matrix where each row is a component of the time series and the columns correpospond to the times.
#' @param n_iterations number of MCMC iterations.
#' @param q probability of permorming a split at each iteration.
#' @param k_0,nu_0,phi_0,m_0 parameters for the Normal-Inverse-Wishart prior for \eqn{(\mu,\lambda)}.
#' @param prior_theta_c,prior_theta_d parameters for the shifted Gamma priod for \eqn{\theta}.
#' @param prior_var_gamma parameters for the Gamma prior for \eqn{\gamma}.
#' @param print_progress If TRUE (default) print the progress bar.
#' @param user_seed seed for random distribution generation.
#' @return Function \code{detect_cp_multi} returns a list containing the following components: \itemize{
#' \item{\code{$orders}} a matrix where each row corresponds to the output order of the corresponding iteration.
#' \item{\code{$gamma_MCMC}} traceplot for \eqn{\gamma}.
#' \item{\code{$gamma_MCMC_01}} a \eqn{0/1} vector, the \eqn{n}-th element is equal to \eqn{1} if the proposed \eqn{\gamma} was accepted, \eqn{0} otherwise.
#' \item{\code{$sigma_MCMC}} traceplot for \eqn{\sigma}.
#' \item{\code{$sigma_MCMC_01}} a \eqn{0/1} vector, the \eqn{n}-th element is equal to \eqn{1} if the proposed \eqn{\sigma} was accepted, \eqn{0} otherwise.
#' \item{\code{$theta_MCMC}} traceplot for \eqn{\theta}.
#' }
#'
#'@examples
#'
#' data_mat <- matrix(NA, nrow = 3, ncol = 100)
#'
#' data_mat[1,] <- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
#' data_mat[2,] <- as.numeric(c(rnorm(50,0,0.125), rnorm(50,1,0.225)))
#' data_mat[3,] <- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))
#'
#' out <- detect_cp_multi(data = data_mat,
#'                               n_iterations = 2500,
#'                               q = 0.25,k_0 = 0.25, nu_0 = 4, phi_0 = diag(1,3,3), m_0 = rep(0,3),
#'                               par_theta_c = 2, par_theta_d = 0.2, prior_var_gamma = 0.1)
#'
#' get_clust_VI(out$order)
#' @export
detect_cp_multi <- function(data, n_iterations, q, k_0, nu_0, phi_0, m_0, par_theta_c = 1, par_theta_d = 1, prior_var_gamma = 0.1, print_progress = TRUE, user_seed = 1234L) {
    .Call(`_BayesCPs_detect_cp_multi`, data, n_iterations, q, k_0, nu_0, phi_0, m_0, par_theta_c, par_theta_d, prior_var_gamma, print_progress, user_seed)
}

#' Clustering Epidemiological survival functions with common changes in time
#'
#' @param data a matrix where each entry is the number of infected for a population (row) at a specific discrete time (column).
#' @param n_iterations Second value
#' @param M number of Monte Carlo iterations when computing the likelihood of the survival function.
#' @param B number of orders for the normalisation constant.
#' @param L number of split-merge steps for the proposal step.
#' @param gamma recovery rate fixed constant for each population at each time.
#' @param alpha \eqn{\alpha} for the acceptance ration in the split-merge procedure.
#' @param q probability of performing a split when updating the single order for the proposal procedure.
#' @param dt,a0,b0,c0,d0 parameters for the computation of the integrated likelihood of the survival functions.
#' @param MH_var variance for the Metropolis-Hastings estimation of the proportion of infected at time 0.
#' @param S0,R0 parameters for the SDE solver.
#' @param p prior average number of change points for each order.
#' @param coars coarsening parameter.
#' @param print_progress If TRUE (default) print the progress bar.
#' @param user_seed seed for random distribution generation.
#' @return Function \code{cluster_cp_EPI} returns a list containing the following components: \itemize{
#' \item{\code{$clust}} a matrix where each row corresponds to the output cluster of the corresponding iteration.
#' \item{\code{$orders}} a multidimensional matrix where each slice is a matrix with the orders associated to the output cluster of that iteration.
#' \item{\code{$llik}} a matrix containing the log-likelihood of each population at each iteration.
#' \item{\code{$rho}} traceplot for the proportion of infected individuals at time 0.
#' }
#'
#'@examples
#'
#' data_mat <- matrix(NA, nrow = 5, ncol = 50)
#'
#' betas <- list(c(rep(0.45, 25),rep(0.14,25)),
#'               c(rep(0.55, 25),rep(0.11,25)),
#'               c(rep(0.50, 25),rep(0.12,25)),
#'               c(rep(0.52, 10),rep(0.15,40)),
#'               c(rep(0.53, 10),rep(0.13,40)))
#'
#'  inf_times <- list()
#'
#'  for(i in 1:5){
#'
#'    inf_times[[i]] <- sim_epi_data(S0 = 10000, I0 = 10, MaxTime = 50, beta_vec = betas[[i]], gamma_0 = 1/8)
#'
#'    vec <- rep(0,50)
#'    names(vec) <- as.character(1:50)
#'
#'    for(j in 1:50){
#'      if(as.character(j) %in% names(table(floor(inf_times[[i]])))){
#'        vec[j] = table(floor(inf_times[[i]]))[which(names(table(floor(inf_times[[i]]))) == j)]
#'      }
#'    }
#'    data_mat[i,] <- vec
#'  }
#'
#'  out <- cluster_cp_EPI(data = data_mat, n_iterations = 5000, M = 500, B = 1000, L = 1)
#'
#'  get_clust_VI(out$clust[1000:5000,])
#' @export
cluster_cp_epi <- function(data, n_iterations, M, B, L, gamma = 1/8, alpha = 1, q = 0.1, dt = 0.1, a0 = 4, b0 = 10, c0 = 1, d0 = 1, MH_var = 0.01, S0 = 1, R0 = 0, p = 0.003, coars = 1, print_progress = TRUE, user_seed = 1234L) {
    .Call(`_BayesCPs_cluster_cp_epi`, data, n_iterations, M, B, L, gamma, alpha, q, dt, a0, b0, c0, d0, MH_var, S0, R0, p, coars, print_progress, user_seed)
}

#' Clustering univariate times series with common changes in time
#'
#' @param data a matrix where each row is an observation and each column corresponds to a discrete time.
#' @param n_iterations number of MCMC iterations.
#' @param B number of orders for the normalisation constant.
#' @param L number of split-merge steps for the proposal step.
#' @param gamma,a,b,c parameters \eqn{\gamma} of the integrated likelihood.
#' @param q probability of a split in the split-merge proposal and acceleration step.
#' @param alpha_SM \eqn{\alpha} for the split-merge proposal and acceleration step.
#' @param coars coarsening coefficient, must be in (0,1].
#' @param print_progress If TRUE (default) print the progress bar.
#' @param user_seed seed for random distribution generation.
#' @return Function \code{cluster_cp_uni} returns a list containing the following components: \itemize{
#' \item{\code{$clust}} a matrix where each row corresponds to the output cluster of the corresponding iteration.
#' \item{\code{$orders}} a multidimensional array where each slice is a matrix and represent an iteration. The row of each matrix correspond the order associated to the corresponding cluster.
#' \item{\code{$norm_vec}} a vector containing the normalisation constant computed at the beginning of the algorithm.
#' }
#'
#' @examples
#'
#' data_mat <- matrix(NA, nrow = 5, ncol = 100)
#'
#' data_mat[1,] <- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
#' data_mat[2,] <- as.numeric(c(rnorm(50,0,0.125), rnorm(50,1,0.225)))
#' data_mat[3,] <- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))
#' data_mat[4,] <- as.numeric(c(rnorm(25,0,0.135), rnorm(75,1,0.225)))
#' data_mat[5,] <- as.numeric(c(rnorm(25,0,0.155), rnorm(75,1,0.280)))
#'
#' out <- cluster_cp_uni(data = data_mat, n_iterations = 5000, B = 1000, L = 1, gamma = 0.5)
#'
#' get_clust_VI(out$clust[2500:5000,])
#'
#' @export
cluster_cp_uni <- function(data, n_iterations, B, L, gamma, a = 1, b = 1, c = 1, q = 0.5, alpha_SM = 0.1, coars = 1, print_progress = TRUE, user_seed = 1234L) {
    .Call(`_BayesCPs_cluster_cp_uni`, data, n_iterations, B, L, gamma, a, b, c, q, alpha_SM, coars, print_progress, user_seed)
}

#' Clustering multivariate times series with common changes in time
#'
#' @param data a multidimensional matrix where each element is a matrix whose rows are the observations and columns the dimensions.
#' @param n_iterations number of MCMC iterations.
#' @param B number of orders for the normalisation constant.
#' @param L number of split-merge steps for the proposal step.
#' @param gamma,k_0,nu_0,phi_0,m_0 parameters of the integrated likelihood.
#' @param q probability of a split in the split-merge proposal and acceleration step.
#' @param alpha_SM \eqn{\alpha} for the split-merge proposal and acceleration step.
#' @param coars coarsening coefficient, must be in (0,1].
#' @param print_progress If TRUE (default) print the progress bar.
#' @param user_seed seed for random distribution generation.
#' @return Function \code{cluster_cp_multi} returns a list containing the following components: \itemize{
#' \item{\code{$clust}} a matrix where each row corresponds to the output cluster of the corresponding iteration.
#' \item{\code{$orders}} a multidimensional array where each slice is a matrix and represent an iteration. The row of each matrix correspond the order associated to the corresponding cluster.
#' \item{\code{$norm_vec}} a vector containing the normalisation constant computed at the beginning of the algorithm.
#' }
#'
#' @examples
#'
#' data_array <- array(data = NA, dim = c(3,100,5))
#'
#' data_array[1,,1] <- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
#' data_array[2,,1] <- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
#' data_array[3,,1] <- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
#'
#' data_array[1,,2] <- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
#' data_array[2,,2] <- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
#' data_array[3,,2] <- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
#'
#' data_array[1,,3] <- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))
#' data_array[2,,3] <- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))
#' data_array[3,,3] <- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))
#'
#' data_array[1,,4] <- as.numeric(c(rnorm(25,0,0.135), rnorm(75,1,0.225)))
#' data_array[2,,4] <- as.numeric(c(rnorm(25,0,0.135), rnorm(75,1,0.225)))
#' data_array[3,,4] <- as.numeric(c(rnorm(25,0,0.135), rnorm(75,1,0.225)))
#'
#' data_array[1,,5] <- as.numeric(c(rnorm(25,0,0.155), rnorm(75,1,0.280)))
#' data_array[2,,5] <- as.numeric(c(rnorm(25,0,0.155), rnorm(75,1,0.280)))
#' data_array[3,,5] <- as.numeric(c(rnorm(25,0,0.155), rnorm(75,1,0.280)))
#'
#' out <- cluster_cp_multi(data = data_array, n_iterations = 5000, B = 1000, L = 1,
#'                         gamma = 0.1, k_0 = 0.25, nu_0 = 5, phi_0 = diag(0.1,3,3), m_0 = rep(0,3))
#'
#' get_clust_VI(out$clust[2500:5000,])
#'
#' @export
cluster_cp_multi <- function(data, n_iterations, B, L, gamma, k_0, nu_0, phi_0, m_0, q = 0.5, alpha_SM = 0.1, coars = 1, print_progress = TRUE, user_seed = 1234L) {
    .Call(`_BayesCPs_cluster_cp_multi`, data, n_iterations, B, L, gamma, k_0, nu_0, phi_0, m_0, q, alpha_SM, coars, print_progress, user_seed)
}

